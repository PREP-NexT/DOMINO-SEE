<!doctype html>
<html class="no-js" lang="en" data-content_root="../../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />
        <link rel="prefetch" href="../../../_static/logo.png" as="image" />
        <link rel="prefetch" href="../../../_static/logo_dark.png" as="image" />

    <!-- Generated with Sphinx 7.4.7 and Furo 2025.07.19 -->
        <title>dominosee.grid.grid - Documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?v=25af2a20" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?v=8dab3a3b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css?v=65f81627" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/notebook.css?v=d56e5f91" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-brand-primary: #0077B5;
  --color-brand-content: #0077B5;
  --color-admonition-background: #F5F7F9;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #2b2b2b;
  --color-code-foreground: #f8f8f2;
  --color-brand-primary: #5CBBFF;
  --color-brand-content: #5CBBFF;
  --color-admonition-background: #242C37;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #2b2b2b;
  --color-code-foreground: #f8f8f2;
  --color-brand-primary: #5CBBFF;
  --color-brand-content: #5CBBFF;
  --color-admonition-background: #242C37;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../_static/logo.png" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../_static/logo_dark.png" alt="Dark Logo"/>
  </div>
  
  <span class="sidebar-brand-text">Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quickstart</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../notebooks/index.html">Notebooks</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Notebooks</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/eca_network.html">Event Coincidence Analysis (ECA) networks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/es_network.html">Event Synchronization (ES) networks</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../api/index.html">API Reference</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of API Reference</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../api/eventorize.html">Event Selection (dominosee.eventorize)</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Event Selection (dominosee.eventorize)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.eventorize.get_event.html">dominosee.eventorize.get_event</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.eventorize.cut_single_threshold.html">dominosee.eventorize.cut_single_threshold</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.eventorize.select_start_consecutive.html">dominosee.eventorize.select_start_consecutive</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.eventorize.select_end_consecutive.html">dominosee.eventorize.select_end_consecutive</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.eventorize._select_burst.html">dominosee.eventorize._select_burst</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.eventorize._select_wane.html">dominosee.eventorize._select_wane</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.eventorize._start_consecutive.html">dominosee.eventorize._start_consecutive</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.eventorize._end_consecutive.html">dominosee.eventorize._end_consecutive</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../api/eca.html">Event Coincidence Analysis (dominosee.eca)</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of Event Coincidence Analysis (dominosee.eca)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.eca.get_eca_precursor.html">dominosee.eca.get_eca_precursor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.eca.get_eca_trigger.html">dominosee.eca.get_eca_trigger</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.eca.get_eca_precursor_from_events.html">dominosee.eca.get_eca_precursor_from_events</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.eca.get_eca_trigger_from_events.html">dominosee.eca.get_eca_trigger_from_events</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.eca.get_eca_precursor_window.html">dominosee.eca.get_eca_precursor_window</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.eca.get_eca_trigger_window.html">dominosee.eca.get_eca_trigger_window</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.eca.get_eca_precursor_confidence.html">dominosee.eca.get_eca_precursor_confidence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.eca.get_eca_trigger_confidence.html">dominosee.eca.get_eca_trigger_confidence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.eca.get_prec_confidence.html">dominosee.eca.get_prec_confidence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.eca.get_trig_confidence.html">dominosee.eca.get_trig_confidence</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../api/es.html">Event Synchronization (dominosee.es)</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of Event Synchronization (dominosee.es)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.es.get_event_positions.html">dominosee.es.get_event_positions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.es.get_event_time_differences.html">dominosee.es.get_event_time_differences</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.es.get_event_sync_from_positions.html">dominosee.es.get_event_sync_from_positions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.es.create_null_model_from_indices.html">dominosee.es.create_null_model_from_indices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.es.convert_null_model_for_locations.html">dominosee.es.convert_null_model_for_locations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.es._extract_event_positions.html">dominosee.es._extract_event_positions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.es._DataArrayTime_to_timeindex.html">dominosee.es._DataArrayTime_to_timeindex</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.es._event_sync.html">dominosee.es._event_sync</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.es._event_sync_null.html">dominosee.es._event_sync_null</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../api/network.html">Network Construction (dominosee.network)</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle navigation of Network Construction (dominosee.network)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.network.get_link_from_threshold.html">dominosee.network.get_link_from_threshold</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.network.get_link_from_significance.html">dominosee.network.get_link_from_significance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.network.get_link_from_confidence.html">dominosee.network.get_link_from_confidence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.network.get_link_from_quantile.html">dominosee.network.get_link_from_quantile</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/generated/dominosee.network.get_link_from_critical_values.html">dominosee.network.get_link_from_critical_values</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/grid.html">Grid Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Publications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../citations.html">Citation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <h1>Source code for dominosee.grid.grid</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Equidistant points on a sphere.</span>

<span class="sd">Fibbonachi Spiral:</span>
<span class="sd">https://bduvenhage.me/geometry/2019/07/31/generating-equidistant-vectors.html</span>

<span class="sd">Fekete points:</span>
<span class="sd">https://arxiv.org/pdf/0808.1202.pdf</span>

<span class="sd">Geodesic grid: (sec. 3.2)</span>
<span class="sd">https://arxiv.org/pdf/1711.05618.pdf</span>

<span class="sd">Review on geodesic grids:</span>
<span class="sd">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.113.997&amp;rep=rep1&amp;type=pdf</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># Original work Copyright (C) 2022 Felix Strnad &lt;felix.strnad@uni-tuebingen.de&gt;</span>
<span class="c1"># From: https://github.com/mlcs/climnet/blob/main/climnet/grid/grid.py</span>
<span class="c1"># Modifications Copyright (C) 2025 Hui-Min Wang &lt;wanghuimin@u.nus.edu&gt;</span>
<span class="c1"># </span>
<span class="c1"># This program is free software: you can redistribute it and/or modify it under the</span>
<span class="c1"># terms of the GNU General Public License as published by the Free Software</span>
<span class="c1"># Foundation, either version 3 of the License, or (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program. If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>
<span class="c1"># -----------------------------------------------------------------------------</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Any</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">SphericalVoronoi</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">Rot</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.fekete</span><span class="w"> </span><span class="kn">import</span> <span class="n">bendito</span><span class="p">,</span> <span class="n">points_on_sphere</span>

<span class="k">class</span><span class="w"> </span><span class="nc">BaseGrid</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract base class for geographical grids.</span>
<span class="sd">    </span>
<span class="sd">    This class provides the common interface and functionality for different</span>
<span class="sd">    types of geographical grids.</span>
<span class="sd">    </span>
<span class="sd">    Attributes:</span>
<span class="sd">        grid: Dictionary containing grid coordinates with &#39;lat&#39; and &#39;lon&#39; keys</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_distance_equator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return distance between points at the equator in km.&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create and return the grid as a dictionary with &#39;lat&#39; and &#39;lon&#39; keys.&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">to_pickle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save grid to pickle file.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            filepath: Path where to save the pickled grid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
    
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_pickle</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load grid from pickle file.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            filepath: Path to the pickled grid file</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            Grid instance loaded from file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">cut_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lat_range</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">lon_range</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract grid points within specified latitude and longitude ranges.</span>

<span class="sd">        TODO: allow taking regions around the date line (longitude wrap-around)</span>
<span class="sd">        Note: Ranges crossing the date line (longitude wrap-around) are not yet supported.</span>

<span class="sd">        Args:</span>
<span class="sd">            lat_range: (min_lat, max_lat) in degrees</span>
<span class="sd">            lon_range: (min_lon, max_lon) in degrees</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            Dictionary with &#39;lat&#39; and &#39;lon&#39; keys containing filtered coordinates</span>
<span class="sd">            </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If longitude range crosses the date line</span>
<span class="sd">            RuntimeError: If no grid has been created yet</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No grid exists. Call create_grid() first.&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">lon_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lon_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Ranges around the date line are not yet supported.&quot;</span><span class="p">)</span>
            
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cutting grid to lat: </span><span class="si">{</span><span class="n">lat_range</span><span class="si">}</span><span class="s2">, lon: </span><span class="si">{</span><span class="n">lon_range</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">lat_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> 
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">lat_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> 
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">lon_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> 
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">lon_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">cut_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">][</span><span class="n">mask</span><span class="p">],</span> <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">][</span><span class="n">mask</span><span class="p">]}</span>
        
        <span class="k">return</span> <span class="n">cut_grid</span>


<span class="k">class</span><span class="w"> </span><span class="nc">RegularGrid</span><span class="p">(</span><span class="n">BaseGrid</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Gaussian Grid of the earth which is the classical grid type.</span>

<span class="sd">    [WIP] This class is under development and not fully tested.</span>

<span class="sd">    Args:</span>
<span class="sd">    ----</span>
<span class="sd">    grid_step_lon: float </span>
<span class="sd">        Grid step in longitudinal direction in degree</span>
<span class="sd">    grid_step_lat: float</span>
<span class="sd">        Grid step in longitudinal direction in degree</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_step_lon</span><span class="p">,</span> <span class="n">grid_step_lat</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_step_lon</span> <span class="o">=</span> <span class="n">grid_step_lon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_step_lat</span> <span class="o">=</span> <span class="n">grid_step_lat</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span>
        <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">create_grid</span><span class="p">()</span> 

    <span class="k">def</span><span class="w"> </span><span class="nf">create_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create regular grid with specified longitude and latitude steps.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Dictionary with &#39;lat&#39; and &#39;lon&#39; keys containing grid coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">init_lon</span><span class="p">,</span> <span class="n">init_lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_regular_lon_lat_step</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_step_lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_step_lat</span><span class="p">)</span>

        <span class="n">lon_mesh</span><span class="p">,</span> <span class="n">lat_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">init_lon</span><span class="p">,</span> <span class="n">init_lat</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">lat_mesh</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">lon_mesh</span><span class="o">.</span><span class="n">flatten</span><span class="p">()}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
        
    <span class="k">def</span><span class="w"> </span><span class="nf">get_distance_equator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return distance between points at the equator.&quot;&quot;&quot;</span>
        <span class="n">d_lon</span> <span class="o">=</span> <span class="n">deg_to_equatorial_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_step_lon</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">6371</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d_lon</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_regular_lon_lat_step</span><span class="p">(</span><span class="n">lon_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">lat_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create longitude and latitude arrays with specified steps, centered within bounds.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            lon_step: Longitude step in degrees</span>
<span class="sd">            lat_step: Latitude step in degrees</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            Tuple of (longitude_array, latitude_array)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_lon</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mi">360</span><span class="o">/</span><span class="n">lon_step</span><span class="p">))</span>
        <span class="n">lon_border</span> <span class="o">=</span> <span class="p">(</span><span class="mi">360</span> <span class="o">-</span> <span class="p">(</span><span class="n">num_lon</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">lon_step</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">num_lat</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mi">180</span><span class="o">/</span><span class="n">lat_step</span><span class="p">))</span>
        <span class="n">lat_border</span> <span class="o">=</span> <span class="p">(</span><span class="mi">180</span> <span class="o">-</span> <span class="p">(</span><span class="n">num_lat</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">lat_step</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">180</span> <span class="o">+</span> <span class="n">lon_border</span><span class="p">,</span> <span class="mi">180</span> <span class="o">-</span> <span class="n">lon_border</span><span class="p">,</span> <span class="n">num_lon</span><span class="p">)</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span> <span class="o">+</span> <span class="n">lat_border</span><span class="p">,</span> <span class="mi">90</span> <span class="o">-</span> <span class="n">lat_border</span><span class="p">,</span> <span class="n">num_lat</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span>


<span class="k">class</span><span class="w"> </span><span class="nc">GaussianGrid</span><span class="p">(</span><span class="n">BaseGrid</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Gaussian Grid of the earth which is the classical grid type.</span>

<span class="sd">    [WIP] This class is under development and not fully tested.</span>

<span class="sd">    Args:</span>
<span class="sd">    ----</span>
<span class="sd">    grid_step_lon: float </span>
<span class="sd">        Grid step in longitudinal direction in degree</span>
<span class="sd">    grid_step_lat: float</span>
<span class="sd">        Grid step in longitudinal direction in degree</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_step_lon</span><span class="p">,</span> <span class="n">grid_step_lat</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_step_lon</span> <span class="o">=</span> <span class="n">grid_step_lon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_step_lat</span> <span class="o">=</span> <span class="n">grid_step_lat</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span>
        <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">create_grid</span><span class="p">()</span>



    <span class="k">def</span><span class="w"> </span><span class="nf">create_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># TODO: 确认高斯网格的起止点</span>
        <span class="n">init_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mf">89.5</span><span class="p">,</span> <span class="mf">90.5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_step_lat</span><span class="p">)</span>
        <span class="n">init_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mf">179.5</span><span class="p">,</span> <span class="mf">180.5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_step_lon</span><span class="p">)</span>

        <span class="n">lon_mesh</span><span class="p">,</span> <span class="n">lat_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">init_lon</span><span class="p">,</span> <span class="n">init_lat</span><span class="p">)</span> <span class="c1"># lats as repeat, lons as tile</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">lat_mesh</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">lon_mesh</span><span class="o">.</span><span class="n">flatten</span><span class="p">()}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
        


    <span class="k">def</span><span class="w"> </span><span class="nf">get_distance_equator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return distance between points at the equator.&quot;&quot;&quot;</span>
        <span class="n">d_lon</span> <span class="o">=</span> <span class="n">deg_to_equatorial_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_step_lon</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">6371</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d_lon</span>


<span class="k">class</span><span class="w"> </span><span class="nc">FibonacciGrid</span><span class="p">(</span><span class="n">BaseGrid</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fibonacci sphere creates a equidistance grid on a sphere.</span>
<span class="sd">    </span>
<span class="sd">    [WIP] This class is under development and not fully tested.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    distance_between_points: float</span>
<span class="sd">        Distance between the equidistance grid points in km.</span>
<span class="sd">    grid: dict (or &#39;old&#39; makes old version of fib grid, &#39;maxmin&#39; to maximize min. min-distance)</span>

<span class="sd">        If grid is already computed, e.g. {&#39;lon&#39;: [], &#39;lat&#39;: []}. Default: None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance_between_points</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.36</span><span class="p">,</span> <span class="n">save</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="n">distance_between_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span> <span class="o">=</span> <span class="n">distance_to_grid_num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># maxavg is standard</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">create_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">save</span> <span class="o">=</span> <span class="n">save</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">=</span> <span class="n">epsilon</span>
        <span class="k">elif</span> <span class="n">grid</span> <span class="o">==</span> <span class="s1">&#39;old&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">create_grid</span><span class="p">(</span><span class="s1">&#39;old&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">grid</span> <span class="o">==</span> <span class="s1">&#39;maxmin&#39;</span><span class="p">:</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxmin_epsilon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">create_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">save</span> <span class="o">=</span> <span class="n">save</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">=</span> <span class="n">eps</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reduced_grid</span> <span class="o">=</span> <span class="kc">None</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">create_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_points</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.36</span><span class="p">,</span> <span class="n">save</span> <span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">num_points</span> <span class="o">==</span> <span class="s1">&#39;old&#39;</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Create Fibonacci grid.&quot;&quot;&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Create fibonacci grid with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="si">}</span><span class="s1"> points.&#39;</span><span class="p">)</span>
            <span class="n">cartesian_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fibonacci_sphere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="p">)</span>
            <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">cart_to_geo</span><span class="p">(</span><span class="n">cartesian_grid</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span>
                                        <span class="n">cartesian_grid</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span>
                                        <span class="n">cartesian_grid</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;fibonaccigrid_</span><span class="si">{</span><span class="n">num_points</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">epsilon</span><span class="si">}</span><span class="s1">.p&#39;</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Load Fibonacci grid with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="si">}</span><span class="s1"> points and epsilon = </span><span class="si">{</span><span class="n">epsilon</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Create refined fibonacci grid with </span><span class="si">{</span><span class="n">num_points</span><span class="si">}</span><span class="s1"> points and epsilon = </span><span class="si">{</span><span class="n">epsilon</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
                <span class="n">goldenRatio</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">5</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_points</span><span class="p">)</span> 
                <span class="n">theta</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">i</span> <span class="o">/</span> <span class="n">goldenRatio</span>
                <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">epsilon</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">num_points</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">epsilon</span><span class="p">))</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
                <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">cart_to_geo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">}</span>
                <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
                    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">fibonacci_sphere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_points</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates the fibonacci sphere points on a unit sphere.</span>
<span class="sd">        Code inspired by:</span>
<span class="sd">        https://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="mf">3.</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">5.</span><span class="p">))</span>  <span class="c1"># golden angle in radians</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_points</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">num_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c1"># y goes from 1 to -1</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># radius at y</span>

            <span class="n">theta</span> <span class="o">=</span> <span class="n">phi</span> <span class="o">*</span> <span class="n">i</span>  <span class="c1"># golden angle increment</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">radius</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">radius</span>

            <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">fibonacci_refined</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_points</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.36</span><span class="p">):</span> <span class="c1"># epsilon = 0.36 for optimal average distance</span>
            
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Create refined fibonacci grid with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="si">}</span><span class="s1"> points and epsilon=</span><span class="si">{</span><span class="n">epsilon</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>

        <span class="n">goldenRatio</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">5</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_points</span><span class="p">)</span> 
        <span class="n">theta</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">i</span> <span class="o">/</span> <span class="n">goldenRatio</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">epsilon</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">num_points</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">epsilon</span><span class="p">))</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">cartesian2spherical</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get number of points for this grid&#39;s distance setting.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Number of points required for the current distance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">distance_to_grid_num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">fit_numPoints_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fit functional relationship between next-nearest-neighbor distance of</span>
<span class="sd">           fibonacci points and number of points.&quot;&quot;&quot;</span>
        <span class="n">num_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">main_distance</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">num_points</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fibonacci_sphere</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">cart_to_geo</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>

            <span class="n">distance</span> <span class="o">=</span> <span class="n">neighbor_distance</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
            <span class="n">hist</span><span class="p">,</span> <span class="n">bin_edge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">bins</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

            <span class="n">main_distance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bin_edge</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">hist</span><span class="p">)])</span>

        <span class="c1"># fit function</span>
        <span class="n">logx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">main_distance</span><span class="p">)</span>
        <span class="n">logy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">num_points</span><span class="p">)</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">logx</span><span class="p">,</span> <span class="n">logy</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">dist_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1400</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
        <span class="n">y_fit</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">dist_array</span><span class="p">)</span>

        <span class="c1"># # Plot fit and data</span>
        <span class="c1"># fig, ax = plt.subplots()</span>
        <span class="c1"># ax.plot(main_distance, num_points)</span>
        <span class="c1"># ax.plot(dist_array, y_fit )</span>
        <span class="c1"># ax.set_xscale(&#39;linear&#39;)</span>
        <span class="c1"># ax.set_yscale(&#39;linear&#39;)</span>

        <span class="k">return</span> <span class="n">coeffs</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_distance_equator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return distance between points at the equator.&quot;&quot;&quot;</span>
        <span class="k">return</span>  <span class="bp">self</span><span class="o">.</span><span class="n">distance</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_maxmin_epsilon</span><span class="p">(</span><span class="n">num_points</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine optimal epsilon value for maximizing minimum distance between points.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            num_points: Number of points in the grid</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            float: Optimal epsilon value for the given number of points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">num_points</span> <span class="o">&gt;=</span> <span class="mi">600000</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="mi">214</span>
        <span class="k">elif</span> <span class="n">num_points</span><span class="o">&gt;=</span> <span class="mi">400000</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="mi">75</span>
        <span class="k">elif</span> <span class="n">num_points</span><span class="o">&gt;=</span> <span class="mi">11000</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="mi">27</span>
        <span class="k">elif</span> <span class="n">num_points</span><span class="o">&gt;=</span> <span class="mi">890</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="k">elif</span> <span class="n">num_points</span><span class="o">&gt;=</span> <span class="mi">177</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">3.33</span>
        <span class="k">elif</span> <span class="n">num_points</span><span class="o">&gt;=</span> <span class="mi">24</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1.33</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.33</span>
        <span class="k">return</span> <span class="n">epsilon</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">keep_original_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orig_grid</span><span class="p">,</span> <span class="n">regular</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">create_grid</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">regular</span><span class="p">:</span>
            <span class="n">new_lon</span><span class="p">,</span> <span class="n">new_lat</span><span class="p">,</span> <span class="n">dists</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">orig_grid</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">]))</span>
            <span class="n">lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">orig_grid</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">])):</span>
                <span class="n">lo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">la</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">pm_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">lons</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">lo</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">lons</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">lo</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
                <span class="n">pm_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">lats</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">la</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">lats</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">la</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pm_lon</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">rel_lon</span> <span class="o">=</span> <span class="p">[</span><span class="n">lons</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lons</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lon_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pm_lon</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">rel_lon</span> <span class="o">=</span> <span class="p">[</span><span class="n">lons</span><span class="p">[</span><span class="n">lon_idx</span><span class="p">],</span> <span class="n">lons</span><span class="p">[</span><span class="n">lon_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pm_lat</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">rel_lat</span> <span class="o">=</span> <span class="p">[</span><span class="n">lats</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lats</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lat_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pm_lat</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">rel_lat</span> <span class="o">=</span> <span class="p">[</span><span class="n">lats</span><span class="p">[</span><span class="n">lat_idx</span><span class="p">],</span> <span class="n">lats</span><span class="p">[</span><span class="n">lat_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">min_dist</span> <span class="o">=</span> <span class="mi">99999</span>
                <span class="k">for</span> <span class="n">l1</span> <span class="ow">in</span> <span class="n">rel_lon</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">l2</span> <span class="ow">in</span> <span class="n">rel_lat</span><span class="p">:</span>
                        <span class="n">this_dist</span> <span class="o">=</span> <span class="n">geo_distance</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">la</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">this_dist</span> <span class="o">&lt;</span> <span class="n">min_dist</span><span class="p">:</span>
                            <span class="n">min_lon</span><span class="p">,</span> <span class="n">min_lat</span> <span class="o">=</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span>
                            <span class="n">min_dist</span> <span class="o">=</span> <span class="n">this_dist</span>
                <span class="n">new_lon</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_lon</span><span class="p">)</span>
                <span class="n">new_lat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_lat</span><span class="p">)</span>
                <span class="n">dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_dist</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reduced_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_lon</span><span class="p">),</span> <span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_lat</span><span class="p">)}</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Only regular grids!&#39;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">min_dists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid2</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">grid2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lon1</span><span class="p">,</span> <span class="n">lon2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">]</span>
            <span class="n">lat1</span><span class="p">,</span> <span class="n">lat2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="mi">9999</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">lon1</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">lon2</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lon1</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">lon1</span><span class="p">))):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
                        <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">geo_distance</span><span class="p">(</span><span class="n">lon1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lat1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lon2</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">lat2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">i</span><span class="o">&gt;</span><span class="n">j</span><span class="p">:</span>
                        <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># min dist from self.grid point to other grid</span>
            <span class="n">lon1</span><span class="p">,</span> <span class="n">lon2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">],</span> <span class="n">grid2</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">]</span>
            <span class="n">lat1</span><span class="p">,</span> <span class="n">lat2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">],</span> <span class="n">grid2</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="mi">9999</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">lon1</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">lon2</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lon1</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lon2</span><span class="p">)):</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">geo_distance</span><span class="p">(</span><span class="n">lon1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lat1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lon2</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">lat2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>


<div class="viewcode-block" id="FeketeGrid">
<a class="viewcode-back" href="../../../api/grid.html#dominosee.grid.grid.FeketeGrid">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FeketeGrid</span><span class="p">(</span><span class="n">BaseGrid</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;FeketeGrid creates a equidistance grid on a sphere.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    num_points: int</span>
<span class="sd">        Number of points to generate on the sphere</span>
<span class="sd">    num_iter: int, optional</span>
<span class="sd">        Number of iterations for grid optimization. Default: 1000</span>
<span class="sd">    grid: None, dict, or tuple, optional</span>
<span class="sd">        Grid initialization method:</span>
<span class="sd">        - None: Create new grid from scratch (default)</span>
<span class="sd">        - dict: Initialize from {&#39;lat&#39;: [...], &#39;lon&#39;: [...]} dictionary</span>
<span class="sd">        - tuple: Initialize from fekete.bendito output (X, dq)</span>
<span class="sd">    parallel: bool or None, optional</span>
<span class="sd">        Whether to use parallel execution. None for auto-detect based on memory</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="FeketeGrid.__init__">
<a class="viewcode-back" href="../../../api/grid.html#dominosee.grid.grid.FeketeGrid.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_points</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
                 <span class="n">grid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                 <span class="n">parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Validate inputs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_points</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">num_points</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_points must be a positive integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_iter</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">num_iter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_iter must be a non-negative integer&quot;</span><span class="p">)</span>
            
        <span class="c1"># Initialize basic parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span> <span class="o">=</span> <span class="n">num_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_iter</span> <span class="o">=</span> <span class="n">num_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dq</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plys_coords</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># Create or load grid based on input type</span>
        <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Case 1: Create new grid from scratch</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">create_grid</span><span class="p">(</span><span class="n">num_iter</span><span class="o">=</span><span class="n">num_iter</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># Case 2: Initialize from lat/lon dictionary</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_from_dict</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="c1"># Case 3: Initialize from fekete.py output tuple</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_grid_from_tuple</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Grid must be None, dict with &#39;lat&#39;/&#39;lon&#39; keys, or tuple from fekete.py output&quot;</span><span class="p">)</span></div>

<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    properties and parameters</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the average distance between points in km.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">grid_num_to_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="p">)</span>

<div class="viewcode-block" id="FeketeGrid.get_distance_equator">
<a class="viewcode-back" href="../../../api/grid.html#dominosee.grid.grid.FeketeGrid.get_distance_equator">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_distance_equator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return distance between points at the equator in km.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span></div>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_determine_parallel_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">num_points</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine whether to use parallel execution based on memory constraints.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            parallel: User preference for parallel execution (None for auto-detect)</span>
<span class="sd">            num_points: Number of points in the grid</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            True if parallel execution should be used, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">parallel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Test if we can allocate the required memory for serial execution</span>
                <span class="n">test_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_points</span><span class="p">,</span> <span class="n">num_points</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">test_array</span>  <span class="c1"># Clean up immediately</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">except</span> <span class="ne">MemoryError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not enough memory to run serially. Running in parallel ...&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">parallel</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    different ways to create FeketeGrid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_create_from_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create grid from lat/lon dictionary.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            grid_dict: Dictionary with &#39;lat&#39; and &#39;lon&#39; keys containing coordinate arrays</span>
<span class="sd">            </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If dictionary format is invalid or arrays have different lengths</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;lat&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">grid_dict</span> <span class="ow">or</span> <span class="s1">&#39;lon&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">grid_dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Grid dict must contain &#39;lat&#39; and &#39;lon&#39; keys&quot;</span><span class="p">)</span>
        
        <span class="c1"># Validate that lat and lon arrays have the same length</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_dict</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_dict</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Latitude and longitude arrays must have the same length&quot;</span><span class="p">)</span>
        
        <span class="c1"># Check if grid length matches num_points</span>
        <span class="n">actual_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_dict</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">actual_points</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Grid has </span><span class="si">{</span><span class="n">actual_points</span><span class="si">}</span><span class="s2"> points but num_points was set to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="si">}</span><span class="s2">. &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;Updating num_points to </span><span class="si">{</span><span class="n">actual_points</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span> <span class="o">=</span> <span class="n">actual_points</span>
        
        <span class="c1"># Store the grid and initialize dq as empty list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grid_dict</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]),</span> <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grid_dict</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">])}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dq</span> <span class="o">=</span> <span class="p">[]</span>
    
<div class="viewcode-block" id="FeketeGrid.create_grid_from_tuple">
<a class="viewcode-back" href="../../../api/grid.html#dominosee.grid.grid.FeketeGrid.create_grid_from_tuple">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_grid_from_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_tuple</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create grid from fekete.bendito output tuple.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            grid_tuple: Tuple containing (X, dq) where X is 3D Cartesian coordinates</span>
<span class="sd">                       and dq is the optimization history</span>
<span class="sd">                       </span>
<span class="sd">        Returns:</span>
<span class="sd">            Dictionary with &#39;lat&#39; and &#39;lon&#39; keys containing grid coordinates</span>
<span class="sd">            </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If tuple format is invalid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dq</span> <span class="o">=</span> <span class="n">grid_tuple</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Grid tuple should contain (coordinates_array, optimization_history)&#39;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Coordinates array should be Nx3 numpy array&#39;</span><span class="p">)</span>
            
        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">cart_to_geo</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">}</span>
        
        <span class="c1"># Check if grid length matches num_points</span>
        <span class="n">actual_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">actual_points</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Grid has </span><span class="si">{</span><span class="n">actual_points</span><span class="si">}</span><span class="s2"> points but num_points was set to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="si">}</span><span class="s2">. &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;Updating num_points to </span><span class="si">{</span><span class="n">actual_points</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span> <span class="o">=</span> <span class="n">actual_points</span>
        
        <span class="k">return</span> <span class="n">grid</span></div>

    
<div class="viewcode-block" id="FeketeGrid.create_grid">
<a class="viewcode-back" href="../../../api/grid.html#dominosee.grid.grid.FeketeGrid.create_grid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create new Fekete grid from scratch.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            num_iter: Number of iterations for grid optimization</span>
<span class="sd">            parallel: Whether to use parallel execution (None for auto-detect)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize with random configuration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_grid</span><span class="p">(</span><span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># TODO: save is kept for future development of `save_epoch`</span>
        
        <span class="c1"># Improve the grid if iterations are requested</span>
        <span class="k">if</span> <span class="n">num_iter</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">improve_grid</span><span class="p">(</span><span class="n">num_iter</span><span class="o">=</span><span class="n">num_iter</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">)</span></div>

<span class="w">        </span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    save and load</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="FeketeGrid.to_pickle">
<a class="viewcode-back" href="../../../api/grid.html#dominosee.grid.grid.FeketeGrid.to_pickle">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_pickle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save FeketeGrid to pickle file.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            filepath: Path to save file. If None, generates default name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filepath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;feketegrid_n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="si">}</span><span class="s1">_i</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_iter</span><span class="si">}</span><span class="s1">.p&#39;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">to_pickle</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span></div>


<div class="viewcode-block" id="FeketeGrid.save_grid">
<a class="viewcode-back" href="../../../api/grid.html#dominosee.grid.grid.FeketeGrid.save_grid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save grid to pickle file.</span>
<span class="sd">        </span>
<span class="sd">        .. deprecated:: </span>
<span class="sd">            Use to_pickle() instead. This method will be removed in a future version.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;save_grid is deprecated and will be removed in a future version. Use to_pickle instead.&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">filepath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;feketegrid_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_iter</span><span class="si">}</span><span class="s1">.p&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dq</span><span class="p">),</span> <span class="n">fp</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="FeketeGrid.load_grid">
<a class="viewcode-back" href="../../../api/grid.html#dominosee.grid.grid.FeketeGrid.load_grid">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_grid</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filepath</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load grid from pickle file.</span>
<span class="sd">        </span>
<span class="sd">        .. deprecated:: </span>
<span class="sd">            Use from_pickle() instead. This method will be removed in a future version.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;load_grid is deprecated and will be removed in a future version. Use from_pickle instead.&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">filepath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;feketegrid_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_iter</span><span class="si">}</span><span class="s1">.p&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dq</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span></div>



<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Core: Initialize =&gt; Improve logic</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="FeketeGrid.initialize_grid">
<a class="viewcode-back" href="../../../api/grid.html#dominosee.grid.grid.FeketeGrid.initialize_grid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">initialize_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Epochwise generation launched. Generating random initial configuration ...&quot;</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">points_on_sphere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="p">)</span>         <span class="c1"># initial random configuration</span>
        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">cart_to_geo</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dq</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;feketegrid_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s1">.p&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_grid</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span></div>

    

<div class="viewcode-block" id="FeketeGrid.improve_grid">
<a class="viewcode-back" href="../../../api/grid.html#dominosee.grid.grid.FeketeGrid.improve_grid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">improve_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">save</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Improve existing grid through optimization iterations.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            num_iter: Number of optimization iterations to perform</span>
<span class="sd">            save: Whether to save the improved grid to file</span>
<span class="sd">            parallel: Whether to use parallel execution (None for auto-detect)</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            Updated grid dictionary with &#39;lat&#39; and &#39;lon&#39; keys</span>
<span class="sd">            </span>
<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If no grid exists to improve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No grid exists to improve. Call initialize_grid() first.&quot;</span><span class="p">)</span>
            
        <span class="n">X0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">geo_to_cart</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">parallel_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_determine_parallel_mode</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="p">)</span> <span class="k">if</span> <span class="n">parallel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">dq</span> <span class="o">=</span> <span class="n">bendito</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">num_iter</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X0</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel_mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dq</span><span class="p">)</span>
        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">cart_to_geo</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">lon</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">lat</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_iter</span> <span class="o">+</span> <span class="n">num_iter</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;feketegrid_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_iter</span><span class="si">}</span><span class="s1">.p&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_grid</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span></div>

<span class="w">        </span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boundaries calculation</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="FeketeGrid.create_SphericalVoronoi">
<a class="viewcode-back" href="../../../api/grid.html#dominosee.grid.grid.FeketeGrid.create_SphericalVoronoi">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_SphericalVoronoi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>
        <span class="n">spVoronoi</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">SphericalVoronoi</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">geo_to_cart</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">)</span>
        <span class="n">spVoronoi</span><span class="o">.</span><span class="n">sort_vertices_of_regions</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regions_vertidx</span> <span class="o">=</span> <span class="n">spVoronoi</span><span class="o">.</span><span class="n">regions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cart_to_geo</span><span class="p">(</span><span class="o">*</span><span class="n">spVoronoi</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regions_vert</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions_vertidx</span><span class="p">]</span>
        <span class="c1"># self.spVoronoi = spVoronoi  # TODO: remove after testing</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions_vert</span></div>

    

    <span class="k">def</span><span class="w"> </span><span class="nf">_harmonize_SphericalVoronoi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">shapely</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sh</span>
        <span class="c1"># 先harmonize个数</span>
        <span class="n">harmonTarget</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions_vert</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">harmonized_regions_vertidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions_vertidx</span>
        <span class="n">harmonized_regions_vertidx</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">harmonTarget</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">),</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> 
                                      <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">harmonized_regions_vertidx</span><span class="p">]</span>
        <span class="c1"># 再harmonize方向(根据ccw)</span>
        <span class="n">harmonized_regions_vertidx</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">if</span> <span class="n">sh</span><span class="o">.</span><span class="n">LinearRing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">is_ccw</span> <span class="k">else</span> <span class="n">r</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                                      <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">harmonized_regions_vertidx</span><span class="p">]</span>
        <span class="c1"># np.array([sh.LinearRing(self.vertices[r, :]).is_ccw for r in harmonized_regions_vertidx]).all() # TEST for ccw</span>
        <span class="c1"># 再生成_plys_coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plys_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="p">:]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">harmonized_regions_vertidx</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plys_coords</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    API for output</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="FeketeGrid.to_cdo_gridfile">
<a class="viewcode-back" href="../../../api/grid.html#dominosee.grid.grid.FeketeGrid.to_cdo_gridfile">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_cdo_gridfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out_vertex</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_gridfile</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">out_vertex</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="FeketeGrid.to_gridfile">
<a class="viewcode-back" href="../../../api/grid.html#dominosee.grid.grid.FeketeGrid.to_gridfile">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_gridfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out_vertex</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">filepath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;feketegrid_n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="si">}</span><span class="s1">_it</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_iter</span><span class="si">}</span><span class="s1">.txt&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;gridtype</span><span class="se">\t</span><span class="s2">= unstructured</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;gridsize</span><span class="se">\t</span><span class="s2">= </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;xsize</span><span class="se">\t</span><span class="s2">= </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ysize</span><span class="se">\t</span><span class="s2">= </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">xvals</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;   &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">))</span>
            <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;xvals</span><span class="se">\t</span><span class="s2">= </span><span class="si">{</span><span class="n">xvals</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">yvals</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;   &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">))</span>
            <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;yvals</span><span class="se">\t</span><span class="s2">= </span><span class="si">{</span><span class="n">yvals</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">out_vertex</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plys_coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">create_SphericalVoronoi</span><span class="p">()</span>
                <span class="c1"># _ = self.harmonize_nvertex()</span>
                <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_harmonize_SphericalVoronoi</span><span class="p">()</span>
                <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nvertex</span><span class="se">\t</span><span class="s2">= </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_plys_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">xbounds</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;   &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plys_coords</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">))</span>
                <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;xbounds</span><span class="se">\t</span><span class="s2">= </span><span class="si">{</span><span class="n">xbounds</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">ybounds</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;   &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plys_coords</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">))</span>
                <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ybounds</span><span class="se">\t</span><span class="s2">= </span><span class="si">{</span><span class="n">ybounds</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;xunits</span><span class="se">\t</span><span class="s2">= degrees</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;yunits</span><span class="se">\t</span><span class="s2">= degrees</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">filepath</span></div>

    
    <span class="c1"># TODO: API to uxarray here!</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utilities</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="FeketeGrid.align_to_target_grid">
<a class="viewcode-back" href="../../../api/grid.html#dominosee.grid.grid.FeketeGrid.align_to_target_grid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">align_to_target_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_coords</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;L-BFGS-B&#39;</span><span class="p">,</span> <span class="n">initial_guess</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Align Fekete grid to target coordinates by minimizing spherical distances.</span>
<span class="sd">        </span>
<span class="sd">        This function uses numerical optimization to find the rotation that minimizes the sum</span>
<span class="sd">        of great circle distances between grid points and their targets. Unlike the Wahba</span>
<span class="sd">        solution which minimizes Euclidean distances, this directly optimizes spherical distances.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target_coords : dict</span>
<span class="sd">            Target coordinates with &#39;lon&#39; and &#39;lat&#39; keys containing arrays of target positions.</span>
<span class="sd">            Must have same length as current grid.</span>
<span class="sd">        method : str, default=&#39;L-BFGS-B&#39;</span>
<span class="sd">            Optimization method. Options: &#39;L-BFGS-B&#39;, &#39;BFGS&#39;, &#39;Powell&#39;, &#39;Nelder-Mead&#39;</span>
<span class="sd">        initial_guess : array-like, optional</span>
<span class="sd">            Initial rotation vector (3,) for optimization. If None, uses Wahba solution as starting point.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            New grid coordinates {&#39;lon&#39;: array, &#39;lat&#39;: array} after optimal spherical alignment.</span>
<span class="sd">            Also contains optimization info: &#39;success&#39;, &#39;message&#39;, &#39;nfev&#39;, &#39;fun&#39;</span>
<span class="sd">            </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Optimization method: **Numerical optimization** (not theoretical solution)</span>
<span class="sd">        - Uses rotation vector parameterization to avoid matrix constraints</span>
<span class="sd">        - Minimizes: Σ arccos(clamp((R @ current_i) · target_i, -1, 1))</span>
<span class="sd">        - No closed-form solution exists for this objective function</span>
<span class="sd">        - Convergence depends on initial guess and grid configuration</span>
<span class="sd">        </span>
<span class="sd">        The rotation vector r represents rotation by ||r|| radians around axis r/||r||.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">minimize</span>
        
        <span class="c1"># Validate inputs (same as previous function)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No Fekete grid exists. Call create_grid() first.&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_coords</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;lat&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target_coords</span> <span class="ow">or</span> <span class="s1">&#39;lon&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target_coords</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;target_coords must be dict with &#39;lat&#39; and &#39;lon&#39; keys&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_coords</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;target_coords must have same length as current grid&quot;</span><span class="p">)</span>
        
        <span class="c1"># Convert to 3D Cartesian coordinates</span>
        <span class="n">curr_x</span><span class="p">,</span> <span class="n">curr_y</span><span class="p">,</span> <span class="n">curr_z</span> <span class="o">=</span> <span class="n">geo_to_cart</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">])</span>
        <span class="n">current_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">curr_x</span><span class="p">,</span> <span class="n">curr_y</span><span class="p">,</span> <span class="n">curr_z</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">current_points</span> <span class="o">=</span> <span class="n">current_points</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">current_points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="n">target_x</span><span class="p">,</span> <span class="n">target_y</span><span class="p">,</span> <span class="n">target_z</span> <span class="o">=</span> <span class="n">geo_to_cart</span><span class="p">(</span><span class="n">target_coords</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">],</span> <span class="n">target_coords</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">])</span>
        <span class="n">target_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">target_x</span><span class="p">,</span> <span class="n">target_y</span><span class="p">,</span> <span class="n">target_z</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">target_points</span> <span class="o">=</span> <span class="n">target_points</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">target_points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="k">def</span><span class="w"> </span><span class="nf">spherical_distance_objective</span><span class="p">(</span><span class="n">rotation_vector</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Objective function: sum of spherical distances after rotation.&quot;&quot;&quot;</span>
            <span class="c1"># Convert rotation vector to rotation matrix</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rotation_vector</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">:</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">Rot</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">rotation_vector</span><span class="p">)</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
            
            <span class="c1"># Apply rotation</span>
            <span class="n">rotated_points</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span> <span class="o">@</span> <span class="n">current_points</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">rotated_points</span> <span class="o">=</span> <span class="n">rotated_points</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rotated_points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            
            <span class="c1"># Compute spherical distances</span>
            <span class="n">dot_products</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rotated_points</span> <span class="o">*</span> <span class="n">target_points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Clamp to [-1, 1] to handle numerical errors</span>
            <span class="n">dot_products</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">dot_products</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="n">spherical_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">dot_products</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">spherical_distances</span><span class="p">)</span>
        
        <span class="c1"># Get initial guess</span>
        <span class="k">if</span> <span class="n">initial_guess</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Use Wahba solution as starting point</span>
            <span class="n">wahba_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">align_to_target_grid</span><span class="p">(</span><span class="n">target_coords</span><span class="p">)</span>
            <span class="c1"># Convert to rotation vector by comparing original and Wahba result</span>
            <span class="n">wahba_x</span><span class="p">,</span> <span class="n">wahba_y</span><span class="p">,</span> <span class="n">wahba_z</span> <span class="o">=</span> <span class="n">geo_to_cart</span><span class="p">(</span><span class="n">wahba_result</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">],</span> <span class="n">wahba_result</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">])</span>
            <span class="n">wahba_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">wahba_x</span><span class="p">,</span> <span class="n">wahba_y</span><span class="p">,</span> <span class="n">wahba_z</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="n">wahba_points</span> <span class="o">=</span> <span class="n">wahba_points</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">wahba_points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            
            <span class="c1"># Find rotation from current to Wahba result</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">current_points</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">wahba_points</span>
            <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Vt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
            <span class="n">R_init</span> <span class="o">=</span> <span class="n">Vt</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">U</span><span class="o">.</span><span class="n">T</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">R_init</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Vt_corrected</span> <span class="o">=</span> <span class="n">Vt</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">Vt_corrected</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">R_init</span> <span class="o">=</span> <span class="n">Vt_corrected</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">U</span><span class="o">.</span><span class="n">T</span>
            
            <span class="n">initial_guess</span> <span class="o">=</span> <span class="n">Rot</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">R_init</span><span class="p">)</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">()</span>
        
        <span class="c1"># Optimize using numerical methods</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
            <span class="n">spherical_distance_objective</span><span class="p">,</span>
            <span class="n">initial_guess</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;ftol&#39;</span><span class="p">:</span> <span class="mf">1e-9</span><span class="p">,</span> <span class="s1">&#39;gtol&#39;</span><span class="p">:</span> <span class="mf">1e-9</span><span class="p">}</span>
        <span class="p">)</span>
        
        <span class="c1"># Apply optimal rotation</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">:</span>
            <span class="n">optimal_R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">optimal_R</span> <span class="o">=</span> <span class="n">Rot</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
        
        <span class="n">final_points</span> <span class="o">=</span> <span class="p">(</span><span class="n">optimal_R</span> <span class="o">@</span> <span class="n">current_points</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">final_points</span> <span class="o">=</span> <span class="n">final_points</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">final_points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="c1"># Convert back to spherical coordinates</span>
        <span class="n">new_lon</span><span class="p">,</span> <span class="n">new_lat</span> <span class="o">=</span> <span class="n">cart_to_geo</span><span class="p">(</span><span class="n">final_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">final_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">final_points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">new_lon</span><span class="p">,</span> 
            <span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">new_lat</span><span class="p">,</span>
            <span class="s1">&#39;success&#39;</span><span class="p">:</span> <span class="n">result</span><span class="o">.</span><span class="n">success</span><span class="p">,</span>
            <span class="s1">&#39;message&#39;</span><span class="p">:</span> <span class="n">result</span><span class="o">.</span><span class="n">message</span><span class="p">,</span>
            <span class="s1">&#39;nfev&#39;</span><span class="p">:</span> <span class="n">result</span><span class="o">.</span><span class="n">nfev</span><span class="p">,</span>
            <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">result</span><span class="o">.</span><span class="n">fun</span>  <span class="c1"># Final spherical distance sum</span>
        <span class="p">}</span></div>

    
<div class="viewcode-block" id="FeketeGrid.map_to_regular_grid">
<a class="viewcode-back" href="../../../api/grid.html#dominosee.grid.grid.FeketeGrid.map_to_regular_grid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">map_to_regular_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_grid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a one-to-one mapping between Fekete grid points and regular grid points.</span>
<span class="sd">        </span>
<span class="sd">        Each Fekete point is mapped to its nearest available regular grid point,</span>
<span class="sd">        ensuring no regular grid point is used twice. Results maintain original Fekete grid order.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target_grid : dict</span>
<span class="sd">            Dictionary with &#39;lon&#39; and &#39;lat&#39; keys containing arrays of regular grid coordinates</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary containing:</span>
<span class="sd">            - &#39;regular_coords&#39;: corresponding regular grid coordinates (lon, lat pairs)</span>
<span class="sd">            - &#39;distances&#39;: distances between mapped points</span>
<span class="sd">            - &#39;unmapped_indices&#39;: indices of Fekete points that couldn&#39;t be mapped</span>
<span class="sd">            </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If no grid has been created yet</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No Fekete grid exists. Call create_grid() first.&quot;</span><span class="p">)</span>
        
        <span class="c1"># Extract and sort unique coordinates from target regular grid</span>
        <span class="n">target_lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">target_grid</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">]))</span>
        <span class="n">target_lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">target_grid</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]))</span>
        
        <span class="n">num_fekete_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">])</span>
        <span class="n">candidate_distances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">candidate_coordinates</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># PHASE 1: Find candidate regular grid points for each Fekete point</span>
        <span class="k">for</span> <span class="n">fekete_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_fekete_points</span><span class="p">):</span>
            <span class="n">fekete_lon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">][</span><span class="n">fekete_idx</span><span class="p">]</span>
            <span class="n">fekete_lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">][</span><span class="n">fekete_idx</span><span class="p">]</span>
            
            <span class="c1"># Find longitude/latitude intervals (same logic as original)</span>
            <span class="n">lon_products</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_lons</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">fekete_lon</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">target_lons</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">fekete_lon</span><span class="p">)</span>
            <span class="n">lat_products</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_lats</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">fekete_lat</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">target_lats</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">fekete_lat</span><span class="p">)</span>
            
            <span class="c1"># Determine bounds</span>
            <span class="n">lon_negative_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lon_products</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon_negative_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">bounding_lons</span> <span class="o">=</span> <span class="p">[</span><span class="n">target_lons</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">target_lons</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lon_idx</span> <span class="o">=</span> <span class="n">lon_negative_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">bounding_lons</span> <span class="o">=</span> <span class="p">[</span><span class="n">target_lons</span><span class="p">[</span><span class="n">lon_idx</span><span class="p">],</span> <span class="n">target_lons</span><span class="p">[</span><span class="n">lon_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
            
            <span class="n">lat_negative_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lat_products</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat_negative_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">bounding_lats</span> <span class="o">=</span> <span class="p">[</span><span class="n">target_lats</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">target_lats</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lat_idx</span> <span class="o">=</span> <span class="n">lat_negative_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">bounding_lats</span> <span class="o">=</span> <span class="p">[</span><span class="n">target_lats</span><span class="p">[</span><span class="n">lat_idx</span><span class="p">],</span> <span class="n">target_lats</span><span class="p">[</span><span class="n">lat_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
            
            <span class="c1"># Calculate distances (same as original)</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">lon</span> <span class="ow">in</span> <span class="n">bounding_lons</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">lat</span> <span class="ow">in</span> <span class="n">bounding_lats</span><span class="p">:</span>
                    <span class="n">distance</span> <span class="o">=</span> <span class="n">geo_distance</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">fekete_lon</span><span class="p">,</span> <span class="n">fekete_lat</span><span class="p">)</span>
                    <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
                    <span class="n">coordinates</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">))</span>
            
            <span class="c1"># Sort by distance</span>
            <span class="n">distance_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
            <span class="n">candidate_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">distances</span><span class="p">)[</span><span class="n">distance_order</span><span class="p">])</span>
            <span class="n">candidate_coordinates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)[</span><span class="n">distance_order</span><span class="p">])</span>
        
        <span class="c1"># PHASE 2: Assignment - using original algorithm but with pre-allocated arrays</span>
        <span class="c1"># Pre-allocate result arrays for better performance</span>
        <span class="n">assigned_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">assigned_distances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">unmapped_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">used_coord_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># Fast O(1) lookup instead of O(n) list search</span>
        
        <span class="c1"># Process in order of nearest distance (like original)</span>
        <span class="n">nearest_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">distances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">distances</span> <span class="ow">in</span> <span class="n">candidate_distances</span><span class="p">])</span>
        <span class="n">processing_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">nearest_distances</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">fekete_idx</span> <span class="ow">in</span> <span class="n">processing_order</span><span class="p">:</span>
            <span class="n">assigned</span> <span class="o">=</span> <span class="kc">False</span>
            
            <span class="c1"># Try each candidate coordinate</span>
            <span class="k">for</span> <span class="n">candidate_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">candidate_coordinates</span><span class="p">[</span><span class="n">fekete_idx</span><span class="p">])):</span>
                <span class="n">coord</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">candidate_coordinates</span><span class="p">[</span><span class="n">fekete_idx</span><span class="p">][</span><span class="n">candidate_idx</span><span class="p">])</span>  <span class="c1"># Convert to tuple for set</span>
                
                <span class="k">if</span> <span class="n">coord</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">used_coord_set</span><span class="p">:</span>
                    <span class="c1"># Assign this coordinate</span>
                    <span class="n">assigned_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
                    <span class="n">assigned_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate_distances</span><span class="p">[</span><span class="n">fekete_idx</span><span class="p">][</span><span class="n">candidate_idx</span><span class="p">])</span>
                    <span class="n">used_coord_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
                    <span class="n">assigned</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">assigned</span><span class="p">:</span>
                <span class="n">unmapped_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fekete_idx</span><span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;No available regular grid points for Fekete point at &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">][</span><span class="n">fekete_idx</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">][</span><span class="n">fekete_idx</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">). &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;Point will be unmapped.&#39;</span>
                <span class="p">)</span>
        
        <span class="c1"># PHASE 3: Restore original Fekete grid order (SIMPLIFIED)</span>
        <span class="n">mapped_fekete_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">processing_order</span> <span class="k">if</span> <span class="n">idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unmapped_indices</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mapped_fekete_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Create inverse mapping to restore original order</span>
            <span class="n">order_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">fekete_idx</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fekete_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mapped_fekete_indices</span><span class="p">)}</span>
            <span class="n">restore_order</span> <span class="o">=</span> <span class="p">[</span><span class="n">order_map</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">mapped_fekete_indices</span><span class="p">)]</span>
            
            <span class="n">final_regular_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">assigned_coords</span><span class="p">)[</span><span class="n">restore_order</span><span class="p">]</span>
            <span class="n">final_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">assigned_distances</span><span class="p">)[</span><span class="n">restore_order</span><span class="p">]</span>
            <span class="n">mapped_fekete_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">mapped_fekete_indices</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">final_regular_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">final_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="n">mapped_fekete_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        
        <span class="k">return</span> <span class="p">{</span>
            <span class="c1"># &#39;fekete_indices&#39;: mapped_fekete_indices,</span>
            <span class="s1">&#39;regular_coords&#39;</span><span class="p">:</span> <span class="n">final_regular_coords</span><span class="p">,</span>
            <span class="s1">&#39;distances&#39;</span><span class="p">:</span> <span class="n">final_distances</span><span class="p">,</span>
            <span class="s1">&#39;unmapped_indices&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unmapped_indices</span><span class="p">)</span>
        <span class="p">}</span></div>
</div>



<span class="k">def</span><span class="w"> </span><span class="nf">grid_num_to_distance</span><span class="p">(</span><span class="n">num_points</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert number of grid points to distance between points.</span>
<span class="sd">    </span>
<span class="sd">    Calculates the corresponding distance between points (in km) for a given</span>
<span class="sd">    number of grid points on an equidistant Earth grid.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        num_points: Number of points on the grid</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Distance between adjacent points in km</span>
<span class="sd">        </span>
<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If num_points is not positive</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; distance = grid_num_to_distance(1000)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Distance: {distance:.2f} km&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">num_points</span><span class="p">,</span> <span class="s1">&#39;item&#39;</span><span class="p">):</span>  <span class="c1"># Handle numpy array elements</span>
        <span class="n">num_points</span> <span class="o">=</span> <span class="n">num_points</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_points</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">num_points</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_points must be a positive integer&quot;</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.01155176</span>  <span class="c1"># Same k as in distance_to_grid_num</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">20.0165958</span><span class="p">)</span>  <span class="c1"># Same a as in distance_to_grid_num</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">num_points</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span>  <span class="c1"># Inverse formula: distance = (num_points/a)^(1/k)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">distance_to_grid_num</span><span class="p">(</span><span class="n">distance</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert distance between points to required number of grid points.</span>
<span class="sd">    </span>
<span class="sd">    Calculates how many grid points are needed to achieve a specific</span>
<span class="sd">    distance between adjacent points (in km) on an equidistant Earth grid.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        distance: Target distance between grid points in km</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Number of grid points required</span>
<span class="sd">        </span>
<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If distance is not positive</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # For 0.25 degree spacing (≈ 27.75 km at equator)</span>
<span class="sd">        &gt;&gt;&gt; num_points = distance_to_grid_num(111*0.25)  # 111 km per degree at equator</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Points needed: {num_points}&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="s1">&#39;item&#39;</span><span class="p">):</span>  <span class="c1"># Handle numpy array elements</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">or</span> <span class="n">distance</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;distance must be a positive number&quot;</span><span class="p">)</span>
    
    <span class="c1"># Constants from log-log fit of grid data</span>
    <span class="n">k</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.01155176</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">20.0165958</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">distance</span><span class="o">**</span><span class="n">k</span><span class="p">)</span>


<span class="c1"># def regular_lon_lat(num_lon, num_lat): # creates regular grid with borders half the distance of one step at each border</span>
<span class="c1">#     lon = np.linspace(-180+360/(2*num_lon),180-360/(2*num_lon),num_lon)</span>
<span class="c1">#     lat = np.linspace(-90 + 180/(2*num_lat), 90 - 180/(2*num_lat), num_lat)</span>
<span class="c1">#     return lon, lat</span>


<span class="k">def</span><span class="w"> </span><span class="nf">cart_to_geo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">z</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert 3D Cartesian coordinates to geographic coordinates (longitude and latitude).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        x: X coordinate in 3D Cartesian space (unit sphere)</span>
<span class="sd">        y: Y coordinate in 3D Cartesian space (unit sphere)</span>
<span class="sd">        z: Z coordinate in 3D Cartesian space (unit sphere)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Tuple of (longitude, latitude) in degrees</span>
<span class="sd">        - longitude: [-180, 180] degrees</span>
<span class="sd">        - latitude: [-90, 90] degrees</span>
<span class="sd">        </span>
<span class="sd">    Note:</span>
<span class="sd">        Input coordinates should be on the unit sphere (x² + y² + z² = 1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
    <span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span>

<span class="k">def</span><span class="w"> </span><span class="nf">geo_to_cart</span><span class="p">(</span><span class="n">lon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">lat</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert geographic coordinates (longitude and latitude) to 3D Cartesian coordinates.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        lon: Longitude in degrees [-180, 180]</span>
<span class="sd">        lat: Latitude in degrees [-90, 90]</span>
<span class="sd">        radius: Radius of the sphere, default is 1 (unit sphere)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Tuple of (x, y, z) coordinates in 3D Cartesian space</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">radius</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;radius must be positive&quot;</span><span class="p">)</span>
        
    <span class="n">lon_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
    <span class="n">lat_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lon_rad</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat_rad</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lon_rad</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat_rad</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat_rad</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>

<span class="nd">@np</span><span class="o">.</span><span class="n">vectorize</span>
<span class="k">def</span><span class="w"> </span><span class="nf">geo_distance</span><span class="p">(</span><span class="n">lon1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">lat1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> 
                <span class="n">lon2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">lat2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> 
                <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">6371</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the great-circle distance between two points on a sphere.</span>
<span class="sd">    </span>
<span class="sd">    Uses the haversine formula to compute the shortest distance over the earth&#39;s surface.</span>
<span class="sd">    This implementation uses arctan2 instead of arcsin for better numerical stability,</span>
<span class="sd">    especially for very small distances.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        lon1: Longitude of first point in degrees</span>
<span class="sd">        lat1: Latitude of first point in degrees</span>
<span class="sd">        lon2: Longitude of second point in degrees</span>
<span class="sd">        lat2: Latitude of second point in degrees</span>
<span class="sd">        radius: Radius of the sphere in km, default is Earth&#39;s radius (6371 km)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Distance between points in the same units as radius</span>
<span class="sd">        </span>
<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If radius is not positive</span>
<span class="sd">        </span>
<span class="sd">    Note:</span>
<span class="sd">        This function is automatically vectorized for numpy arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">radius</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;radius must be positive&quot;</span><span class="p">)</span>
        
    <span class="c1"># Convert to radians</span>
    <span class="n">lon1_rad</span><span class="p">,</span> <span class="n">lat1_rad</span><span class="p">,</span> <span class="n">lon2_rad</span><span class="p">,</span> <span class="n">lat2_rad</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">,</span> <span class="p">[</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">,</span> <span class="n">lon2</span><span class="p">,</span> <span class="n">lat2</span><span class="p">])</span>
    <span class="n">dlon</span> <span class="o">=</span> <span class="n">lon2_rad</span> <span class="o">-</span> <span class="n">lon1_rad</span>
    <span class="n">dlat</span> <span class="o">=</span> <span class="n">lat2_rad</span> <span class="o">-</span> <span class="n">lat1_rad</span>
    
    <span class="c1"># Haversine formula</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlat</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat1_rad</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat2_rad</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlon</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">c</span>


<span class="k">def</span><span class="w"> </span><span class="nf">deg_to_equatorial_distance</span><span class="p">(</span><span class="n">grid_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">6371</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert angular grid resolution (degrees) to equivalent distance at the equator (km).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        grid_step: Angular resolution/spacing in degrees</span>
<span class="sd">        radius: Radius of the sphere in km, default is Earth&#39;s radius (6371 km)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Equivalent spatial distance/spacing in kilometers at the equator</span>
<span class="sd">        </span>
<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If grid_step is not positive</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">grid_step</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;grid_step must be positive&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">geo_distance</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">grid_step</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">equatorial_distance_to_deg</span><span class="p">(</span><span class="n">distance</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">6371</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert equatorial distance (km) to equivalent angular grid resolution (degrees).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        distance: Spatial distance/spacing in kilometers at the equator</span>
<span class="sd">        radius: Radius of the sphere in km, default is Earth&#39;s radius (6371 km)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Equivalent angular resolution/spacing in degrees</span>
<span class="sd">        </span>
<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If distance is not positive</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;distance must be positive&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">distance</span> <span class="o">*</span> <span class="mi">360</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">radius</span><span class="p">)</span>

<span class="c1"># def min_dists(grid1, grid2 = None): TODO: implement grid2 but I dont know why need it</span>
<span class="c1">#     if grid2 is None:</span>
<span class="c1">#         lon1, lon2 = grid1[&#39;lon&#39;], grid1[&#39;lon&#39;]</span>
<span class="c1">#         lat1, lat2 = grid1[&#39;lat&#39;], grid1[&#39;lat&#39;]</span>
<span class="c1">#         d = 9999 * np.ones((len(lon1),len(lon2)))</span>
<span class="c1">#         for i in range(len(lon1)):</span>
<span class="c1">#             for j in range((len(lon1))):</span>
<span class="c1">#                 if i &lt; j:</span>
<span class="c1">#                     d[i,j] = geo_distance(lon1[i], lat1[i], lon2[j], lat2[j])</span>
<span class="c1">#                 elif i&gt;j:</span>
<span class="c1">#                     d[i,j] = d[j,i]</span>
<span class="c1">#         return d.min(axis=1)</span>
<span class="c1">#     else: # min dist from self.grid point to other grid</span>
<span class="c1">#         lon1, lon2 = grid1[&#39;lon&#39;], grid2[&#39;lon&#39;]</span>
<span class="c1">#         lat1, lat2 = grid1[&#39;lat&#39;], grid2[&#39;lat&#39;]</span>
<span class="c1">#         d = 9999 * np.ones((len(lon1),len(lon2)))</span>
<span class="c1">#         for i in range(len(lon1)):</span>
<span class="c1">#             for j in range(len(lon2)):</span>
<span class="c1">#                 d[i,j] = geo_distance(lon1[i], lat1[i], lon2[j], lat2[j])</span>
<span class="c1">#         return d.min(axis=1)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">neighbour_distance</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the distance to the nearest neighboring point for each point in the grid.</span>
<span class="sd">    </span>
<span class="sd">    This function computes the nearest neighbor distance for each point, which is useful</span>
<span class="sd">    for analyzing grid uniformity and identifying spatial outliers.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        grid: Grid dictionary with &#39;lon&#39; and &#39;lat&#39; keys containing coordinates in degrees</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Array of minimum distances (in km) to the nearest neighbor for each point</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">])</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">])</span>
    
    <span class="n">n_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
    
    <span class="c1"># Initialize distance matrix with NaN values</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_points</span><span class="p">,</span> <span class="n">n_points</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    
    <span class="c1"># Calculate distances between all pairs of points (only upper triangle for efficiency)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_points</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_points</span><span class="p">):</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">geo_distance</span><span class="p">(</span><span class="n">lon</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lat</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lon</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">lat</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
            <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>  <span class="c1"># Mirror the distance matrix</span>
    
    <span class="c1"># Set diagonal to infinity to exclude self-distances</span>
    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
    
    <span class="c1"># Find minimum distance for each point</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2025, Hui-Min Wang and Xiaogang He (GPL-3.0)
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              <a class="muted-link " href="https://github.com/PREP-NexT/DOMINO-SEE" aria-label="GitHub">
                <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
            </a>
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../../_static/documentation_options.js?v=d45e8c67"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/furo.js?v=46bd48cc"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=30646c52"></script>
    <script src="../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    </body>
</html>